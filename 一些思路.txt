关于生成数独

    关于简单的不保证唯一解的目前想法如下：
    先随机迭代的生成一个最开始的数独（这可能会比较慢）
        关于这个看到个很有意思的搞法：【二维数独的一种生成方式（仅供参考）-哔哩哔哩】 https://b23.tv/m13nkow
    然后进行随机的行列交换，（不够要同属一九宫格就是只能123行互换，而不能34行互换这样）
    再然后随机的挖空
    如此生成的便是一个数独了
        关于难度：我认为可以是在挖空上做手脚，
        我觉得同一个九宫格/行/列挖走的越多或者一个被挖走的格跟他相关的格（同属一个九宫格/行/列）挖走的越多或许难度越大
        难度的值感觉可以作为一个在选择随即挖空时候对于以上挖空方法的倾向的一个系数
    

    关于生成唯一解的数独：
        查了一下，这个是属于一个np完全问题，所以应该是没有一个时间复杂度上比较简单的算法，或许只能是挖空，然后再去求解他，
        那么如果有超过一个解，我们就把他舍弃，重新选择
        关于挖取的方法有两种思路，一种是一个一个挖取，直到挖到我们需要挖的个数，挖一次我们判断一下会不会导致多解的出现，
        如果会导致多解的出现我们则回溯到挖这一个空之前的状态，随机换一个空进行挖，直到挖到我们需要的空数。
        不过感觉这样会十分的慢。还有一种想法是我一口气直接挖指定个数的，然后我们判断是不是多解，是的话直接重新随机挖，这不需要遍历过程中的所有状态
        解到第二个解的时候我们就可以break重新随机，这样会快非常的多
        hrq同学这两种方法都用了，他跟我讲他实践过程中就是第二个会快非常的多，也可以两种都写一下（时间足够的话），不够就只写第二种
        此外还搜索到了一些快速筛选掉一些非唯一解数独的方法（大多数都是计算机暴力解出来的规律）
            1：一个标准数独题目如果提示数（已知数）少于17个，一定不唯一解
            2：连续的三个空行、三个空列、三个空宫排列在一起，题目一定不唯一解
            3：提示数只有1~9这9个数字的其中7个甚至更少的，一定不唯一解
            4：任何一个并排三宫里出现两行/列是全空的，一定不唯一解（这个没太看懂，并排三宫是个啥）
            5：一个标准数独题目如果有明显的可互换的填数结构（Unavoidable Set），
            一定不唯一解（这点需要参看一下资料：Unavoidable Set，直译为“不可规避集合”，也是数独技巧致命结构利用的地方），我的评价是太难了，没必要预判断

            1，2，3可以预判断一波，感觉还挺容易的（主要显得有工作量）
            来源：https://www.zhihu.com/question/24149895

            

关于数独的求解
    maincode里写了个简单的sudoku类，里面有简单的一个求解方法，具体思路可看代码，就是简单的递归之，这个只能返回一个解。
    但是稍加修改，添加一些flag之类的我们可以改成求解全部解，不过感觉会有更高效的方法求解，不过我们目前的需求来看也不需要求全部解，最多俩解足矣
    慢点似乎也无妨，我看好像可以用一种叫dlx的算法（数据结构？）来进行求解，或许更快吧，但ddl蛮多的懒得看了，有空再看吧